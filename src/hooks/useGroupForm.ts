
import { useState, useEffect } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { GroupFormValues } from '@/components/Groups/GroupInfoForm';
import { Participant, GroupCategory } from '../types';
import { generateGroupName } from '../utils/groupUtils';
import { useToast } from '@/hooks/use-toast';
import { determineGroupCategory } from '../utils/categoryUtils';
import { useQuery } from '@tanstack/react-query';
import { DatabaseService } from '@/services/DatabaseService';

interface UseGroupFormProps {
  form: UseFormReturn<GroupFormValues>;
  initialParticipants?: Participant[];
  currentGroupId?: number;
}

export const useGroupForm = ({ 
  form, 
  initialParticipants = [],
  currentGroupId
}: UseGroupFormProps) => {
  const { toast } = useToast();
  const [selectedParticipants, setSelectedParticipants] = useState<Participant[]>(initialParticipants);
  const [availableParticipants, setAvailableParticipants] = useState<Participant[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<GroupCategory>(form.watch('category') as GroupCategory);
  const [isNameAutoGenerated, setIsNameAutoGenerated] = useState(true);

  // Fetch participants from database
  const { data: participants = [] } = useQuery({
    queryKey: ['participants'],
    queryFn: DatabaseService.getAllParticipants,
    staleTime: 5 * 60 * 1000,
  });

  // Get the current values from the form
  const { size } = form.watch();

  // Update available participants
  useEffect(() => {
    // If we have participants already selected, don't clear them when category changes
    if (initialParticipants.length === 0) {
      setSelectedParticipants([]); // Clear selected participants when category changes if not editing
    }
    
    // Make all participants available, regardless of category
    // The category filtering will be handled in the AvailableParticipants component
    setAvailableParticipants(participants);
  }, [participants, initialParticipants.length]);

  // Auto-generate group name when selected participants change
  useEffect(() => {
    if (isNameAutoGenerated && selectedParticipants.length > 0) {
      const generatedName = generateGroupName(selectedParticipants);
      form.setValue('name', generatedName);
    }
  }, [selectedParticipants, isNameAutoGenerated, form]);

  // Determine category based on participants
  useEffect(() => {
    if (selectedParticipants.length > 0) {
      // Let categoryUtils determine the category
      const category = determineGroupCategory(selectedParticipants);
      form.setValue('category', category);
      setSelectedCategory(category);
    }
  }, [selectedParticipants, form]);

  // Handle adding a participant to the group
  const addParticipant = (participant: Participant) => {
    // Check if we've reached the maximum number of participants for the selected size
    const maxParticipants = size === 'three' ? 3 : 4;
    if (selectedParticipants.length >= maxParticipants) {
      toast({
        title: "Maximale Anzahl erreicht",
        description: `Eine ${size === 'three' ? 'Dreier' : 'Vierer'}gruppe kann maximal ${maxParticipants} Teilnehmer haben.`,
        variant: "destructive"
      });
      return;
    }

    // Check if participant is already selected
    if (selectedParticipants.some(p => p.id === participant.id)) {
      toast({
        title: "Teilnehmer bereits ausgewÃ¤hlt",
        description: `${participant.firstName} ${participant.lastName} ist bereits in dieser Gruppe.`,
        variant: "destructive"
      });
      return;
    }

    const updatedSelectedParticipants = [...selectedParticipants, participant];
    setSelectedParticipants(updatedSelectedParticipants);
    
    // Update the name immediately if auto-generated
    if (isNameAutoGenerated) {
      const generatedName = generateGroupName(updatedSelectedParticipants);
      form.setValue('name', generatedName);
    }
    
    // No longer remove from available participants, just move to the bottom
    setAvailableParticipants([
      ...availableParticipants.filter(p => p.id !== participant.id),
      participant
    ]);
  };

  // Handle removing a participant from the group
  const removeParticipant = (participant: Participant) => {
    const updatedSelectedParticipants = selectedParticipants.filter(p => p.id !== participant.id);
    setSelectedParticipants(updatedSelectedParticipants);
    
    // Update the name immediately if auto-generated
    if (isNameAutoGenerated) {
      const generatedName = generateGroupName(updatedSelectedParticipants);
      form.setValue('name', generatedName);
    }
    
    // Move the participant to the top of available participants
    setAvailableParticipants([
      participant,
      ...availableParticipants.filter(p => p.id !== participant.id)
    ]);
  };

  // Handle name change
  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    form.setValue('name', e.target.value);
    setIsNameAutoGenerated(false);
  };

  // Regenerate name button handler
  const handleRegenerateName = () => {
    const generatedName = generateGroupName(selectedParticipants);
    form.setValue('name', generatedName);
    setIsNameAutoGenerated(true);
  };

  return {
    selectedParticipants,
    setSelectedParticipants,
    availableParticipants,
    selectedCategory,
    isNameAutoGenerated,
    addParticipant,
    removeParticipant,
    handleNameChange,
    handleRegenerateName
  };
};
