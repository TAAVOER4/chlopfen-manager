import { useState, useEffect } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { GroupFormValues } from '@/components/Groups/GroupInfoForm';
import { Participant, GroupCategory } from '../types';
import { generateGroupName } from '../utils/groupUtils';
import { useToast } from '@/hooks/use-toast';
import { determineGroupCategory } from '../utils/categoryUtils';
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/lib/supabase';
import { useTournament } from '@/contexts/TournamentContext';

interface UseGroupFormProps {
  form: UseFormReturn<GroupFormValues>;
  initialParticipants?: Participant[];
  currentGroupId?: number;
}

export const useGroupForm = ({ 
  form, 
  initialParticipants = [],
  currentGroupId
}: UseGroupFormProps) => {
  const { toast } = useToast();
  const { activeTournament } = useTournament();
  const [selectedParticipants, setSelectedParticipants] = useState<Participant[]>(initialParticipants);
  const [availableParticipants, setAvailableParticipants] = useState<Participant[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<GroupCategory>(form.watch('category') as GroupCategory);
  const [isNameAutoGenerated, setIsNameAutoGenerated] = useState(true);

  // Fetch participants directly from Supabase
  const { data: participants = [], isLoading: isLoadingParticipants } = useQuery({
    queryKey: ['participants-for-group', activeTournament?.id],
    queryFn: async () => {
      console.log("Fetching participants directly from Supabase in useGroupForm");
      try {
        const { data, error } = await supabase
          .from('participants')
          .select('*')
          .order('display_order', { ascending: true, nullsFirst: false });
          
        if (error) {
          console.error('Error loading participants:', error);
          return [];
        }
        
        console.log(`Fetched ${data.length} participants in useGroupForm`);
        
        // Map the database column names to the frontend property names
        const transformedData = data.map(participant => ({
          id: participant.id,
          firstName: participant.first_name,
          lastName: participant.last_name,
          location: participant.location,
          birthYear: participant.birth_year,
          category: participant.category,
          isGroupOnly: participant.is_group_only || false,
          tournamentId: participant.tournament_id,
          displayOrder: participant.display_order,
          groupIds: []
        }));
        
        // Fetch all group-participant relationships
        const { data: groupParticipants, error: relError } = await supabase
          .from('group_participants')
          .select('*');
          
        if (relError) {
          console.error('Error loading group-participant relationships:', relError);
        } else if (groupParticipants) {
          // Populate groupIds for each participant
          transformedData.forEach(participant => {
            participant.groupIds = groupParticipants
              .filter(gp => gp.participant_id === participant.id)
              .map(gp => gp.group_id);
          });
        }
        
        return transformedData;
      } catch (error) {
        console.error('Error in direct participant fetch:', error);
        return [];
      }
    },
    staleTime: 0, // Don't cache this data
    gcTime: 0,    // Don't keep this data in memory
  });

  // Watch form changes for category and update selectedCategory
  useEffect(() => {
    const subscription = form.watch((value, { name }) => {
      if (name === 'category') {
        setSelectedCategory(value.category as GroupCategory);
      }
    });
    return () => subscription.unsubscribe();
  }, [form]);

  // Get the current values from the form
  const { size } = form.watch();

  // Update available participants
  useEffect(() => {
    if (isLoadingParticipants) return;
    
    console.log("Updating available participants in useGroupForm");
    console.log("- participants:", participants.length);
    console.log("- initialParticipants:", initialParticipants.length);
    
    // Filter participants to those relevant to the current tournament
    const tournamentParticipants = activeTournament 
      ? participants.filter(p => !p.tournamentId || p.tournamentId === activeTournament.id)
      : participants;
    
    console.log("- tournamentParticipants:", tournamentParticipants.length);
    
    // Make all participants available
    // The category filtering will be handled in the AvailableParticipants component
    setAvailableParticipants(tournamentParticipants);
    
    // If we have participants already selected, don't clear them when category changes
    if (initialParticipants.length === 0 && selectedParticipants.length === 0) {
      // Keep selected participants empty if we're not editing
    }
  }, [participants, initialParticipants.length, isLoadingParticipants, activeTournament]);

  // Auto-generate group name when selected participants change
  useEffect(() => {
    if (isNameAutoGenerated && selectedParticipants.length > 0) {
      const generatedName = generateGroupName(selectedParticipants);
      form.setValue('name', generatedName);
    }
  }, [selectedParticipants, isNameAutoGenerated, form]);

  // Determine category based on participants
  useEffect(() => {
    if (selectedParticipants.length > 0) {
      // Let categoryUtils determine the category
      const category = determineGroupCategory(selectedParticipants);
      form.setValue('category', category);
      setSelectedCategory(category);
    }
  }, [selectedParticipants, form]);

  // Handle adding a participant to the group
  const addParticipant = (participant: Participant) => {
    // Check if we've reached the maximum number of participants for the selected size
    const maxParticipants = size === 'three' ? 3 : 4;
    if (selectedParticipants.length >= maxParticipants) {
      toast({
        title: "Maximale Anzahl erreicht",
        description: `Eine ${size === 'three' ? 'Dreier' : 'Vierer'}gruppe kann maximal ${maxParticipants} Teilnehmer haben.`,
        variant: "destructive"
      });
      return;
    }

    // Check if participant is already selected
    if (selectedParticipants.some(p => p.id === participant.id)) {
      toast({
        title: "Teilnehmer bereits ausgewÃ¤hlt",
        description: `${participant.firstName} ${participant.lastName} ist bereits in dieser Gruppe.`,
        variant: "destructive"
      });
      return;
    }

    const updatedSelectedParticipants = [...selectedParticipants, participant];
    setSelectedParticipants(updatedSelectedParticipants);
    
    // Update the name immediately if auto-generated
    if (isNameAutoGenerated) {
      const generatedName = generateGroupName(updatedSelectedParticipants);
      form.setValue('name', generatedName);
    }
    
    // No longer remove from available participants, just move to the bottom
    setAvailableParticipants([
      ...availableParticipants.filter(p => p.id !== participant.id),
      participant
    ]);
  };

  // Handle removing a participant from the group
  const removeParticipant = (participant: Participant) => {
    const updatedSelectedParticipants = selectedParticipants.filter(p => p.id !== participant.id);
    setSelectedParticipants(updatedSelectedParticipants);
    
    // Update the name immediately if auto-generated
    if (isNameAutoGenerated) {
      const generatedName = generateGroupName(updatedSelectedParticipants);
      form.setValue('name', generatedName);
    }
    
    // Move the participant to the top of available participants
    setAvailableParticipants([
      participant,
      ...availableParticipants.filter(p => p.id !== participant.id)
    ]);
  };

  // Handle name change
  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    form.setValue('name', e.target.value);
    setIsNameAutoGenerated(false);
  };

  // Regenerate name button handler
  const handleRegenerateName = () => {
    const generatedName = generateGroupName(selectedParticipants);
    form.setValue('name', generatedName);
    setIsNameAutoGenerated(true);
  };

  return {
    selectedParticipants,
    setSelectedParticipants,
    availableParticipants,
    selectedCategory,
    isNameAutoGenerated,
    addParticipant,
    removeParticipant,
    handleNameChange,
    handleRegenerateName
  };
};
